<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>我的个人博客</title><link>/Blog/</link><description>记录生活美好</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/f-logo.png</url><title>我的个人博客</title><link>/Blog/</link></image><language>zh-CN</language><lastBuildDate>Tue, 22 Mar 2022 14:50:42 +0806</lastBuildDate><pubDate>Tue, 22 Mar 2022 14:50:42 +0806</pubDate><item><title>Linux性能查看</title><link>/Blog/archives/Linux%E6%80%A7%E8%83%BD%E6%9F%A5%E7%9C%8B/</link><description>&lt;p&gt;&lt;strong&gt;Linux性能查看&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1.1 cpu性能查看
1、查看物理cpu个数：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;cat /proc/cpuinfo |grep &amp;quot;physical id&amp;quot;|sort|uniq|wc -l&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;2、查看每个物理cpu中的core个数：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;cat /proc/cpuinfo |grep &amp;quot;cpu cores&amp;quot;|wc -l&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;3、逻辑cpu的个数：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;cat /proc/cpuinfo |grep &amp;quot;processor&amp;quot;|wc -l&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;物理cpu个数*核数=逻辑cpu个数（不支持超线程技术的情况下）&lt;/p&gt;&lt;p&gt;1.2 内存查看
1、查看内存使用情况：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;#free -m
             total       used       free     shared    buffers     cached
Mem:          3949       2519       1430          0        189       1619
-/+ buffers/cache:        710       3239
Swap:         3576          0       3576&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;total：内存总数
used：已经使用的内存数
free：空闲内存数
shared：多个进程共享的内存总额&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;buffers/cache：(已用)的内存数，即used-buffers-cached&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;buffers/cache：(可用)的内存数，即free+buffers+cached&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Buffer Cache用于针对磁盘块的读写；
Page Cache用于针对文件inode的读写，这些Cache能有效地缩短I/O系统调用的时间。&lt;/p&gt;&lt;p&gt;对操作系统来说free/used是系统可用/占用的内存；
对应用程序来说-/+ buffers/cache是可用/占用内存,因为buffers/cache很快就会被使用。
我们工作时候应该从应用角度来看。&lt;/p&gt;&lt;p&gt;1.3 硬盘查看
1、查看硬盘及分区信息：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;fdisk -l&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;2、查看文件系统的磁盘空间占用情况：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;df -h&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;3、查看硬盘的I/O性能（每隔一秒显示一次，显示5次）：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;iostat -x 1 5&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;iostat是含在套装systat中的,可以用yum -y install systat来安装。&lt;/p&gt;&lt;p&gt;常关注的参数：&lt;/p&gt;&lt;p&gt;如%util接近100%,说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
如idle小于70%，I/O的压力就比较大了，说明读取进程中有较多的wait。
4、查看linux系统中某目录的大小：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;du -sh /root&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如发现某个分区空间接近用完，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录，然后按照从大到小的顺序，找出系统中占用最多空间的前10个文件或目录：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;du -cksh *|sort -rn|head -n 10&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;1.4 查看平均负载
有时候系统响应很慢，但又找不到原因，这时就要查看平均负载了，看它是否有大量的进程在排队等待。&lt;/p&gt;&lt;p&gt;load average:平均负载
平均负载(load average)是指系统的运行队列的平均利用率，也可以认为是可运行进程的平均数。&lt;/p&gt;&lt;p&gt;以路况为例， 单核CPU、单车道 情况如下：&lt;/p&gt;&lt;figure style="flex: 129.0909090909091" &gt;&lt;img width="426" height="165" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/c8dcafada270cd7823d98db870f2c077.png" /&gt;&lt;/figure&gt;&lt;p&gt;0.00-1.00 之间的数字表示此时路况非常良好，没有拥堵，车辆可以毫无阻碍地通过。
1.00 表示道路还算正常，但有可能会恶化并造成拥堵。此时系统已经没有多余的资源了，管理员需要进行优化。
1.00-*** 表示路况不太好了，如果到达2.00表示有桥上车辆一倍数目的车辆正在等待。这种情况你必须进行检查了。
多核CPU - 多车道 情况如下：&lt;/p&gt;&lt;figure style="flex: 386.4864864864865" &gt;&lt;img width="572" height="74" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/ed2da7b99ffd9336f558671cbf6a38c2.png" /&gt;&lt;/figure&gt;&lt;p&gt;多核CPU的话，满负荷状态的数字为 &amp;quot;1.00 * CPU核数&amp;quot;，即双核CPU为2.00，四核CPU为4.00。&lt;/p&gt;&lt;p&gt;一般的进程需要消耗CPU、内存、磁盘I/O、网络I/O等资源，在这种情况下，平均负载就不是单独指的CPU使用情况。即内存、磁盘、网络等因素也可以影响系统的平均负载值。 
在单核处理器中，平均负载值为1或者小于1的时候，系统处理进程会非常轻松，即负载很低。当达到3的时候，就会显得很忙，达到5或者8的时候就不能很好的处理进程了（其中5和8目前还是个争议的阈值，为了保守起见，建议选择低的）。&lt;/p&gt;&lt;p&gt;查看load average 数据
下面几个命令都可以看到 load average&lt;/p&gt;&lt;p&gt;#top 
#uptime 
#w&lt;/p&gt;&lt;p&gt;截图如下：&lt;/p&gt;&lt;p&gt;top 命令的&lt;/p&gt;&lt;figure style="flex: 106.22837370242215" &gt;&lt;img width="614" height="289" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/520beb08519ecb48a5356867cb5b6a6f.png" /&gt;&lt;/figure&gt;&lt;p&gt;uptime 命令的&lt;/p&gt;&lt;figure style="flex: 461.9047619047619" &gt;&lt;img width="582" height="63" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/461b2a7480dd7076a1782c059122a029.png" /&gt;&lt;/figure&gt;&lt;p&gt;w 命令的&lt;/p&gt;&lt;figure style="flex: 271.5" &gt;&lt;img width="543" height="100" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/2117d8f654e3c3af152c7418a7e6b5ea.png" /&gt;&lt;/figure&gt;&lt;p&gt;这里的 load average 的三个值分别指系统在最后 1/5/15分钟 的平均负载值。&lt;/p&gt;&lt;p&gt;根据经验：我们应该把重点放在5/15分钟的平均负载，因为1分钟的平均负载太频繁，一瞬间的高并发就会导致该值的大幅度改变。&lt;/p&gt;&lt;p&gt;1.5 vmstat命令来判断系统是否繁忙
还可以结合vmstat命令来判断系统是否繁忙，其中：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;procs
r：等待运行的进程数。
b：处在非中断睡眠状态的进程数。
w：被交换出去的可运行的进程数。&lt;/p&gt;&lt;p&gt;memeory
swpd：虚拟内存使用情况，单位为KB。
free：空闲的内存，单位为KB。
buff：被用来作为缓存的内存数，单位为KB。&lt;/p&gt;&lt;p&gt;swap
si：从磁盘交换到内存的交换页数量，单位为KB。
so：从内存交换到磁盘的交换页数量，单位为KB。&lt;/p&gt;&lt;p&gt;io
bi：发送到块设备的块数，单位为KB。
bo：从块设备接受的块数，单位为KB。&lt;/p&gt;&lt;p&gt;system
in：每秒的中断数，包括时钟中断。
cs：每秒的环境切换次数。&lt;/p&gt;&lt;p&gt;cpu
按cpu的总使用百分比来显示。
us：cpu使用时间。
sy：cpu系统使用时间。
id：闲置时间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;1.6Linux下可使用 nethogs 工具查看进程流量&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;1.7 其他参数
查看内核版本号：
uname -a&lt;/p&gt;&lt;p&gt;简化命令：uname -r&lt;/p&gt;&lt;p&gt;查看系统是32位还是64位的：
file /sbin/init&lt;/p&gt;&lt;p&gt;查看发行版：
cat /etc/issue
或lsb_release -a&lt;/p&gt;&lt;p&gt;查看系统已载入的相关模块：
lsmod&lt;/p&gt;&lt;p&gt;查看pci设置：
lspci&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;2.1.3 系统性能分析工具
1.常用系统命令
Vmstat、sar、iostat、netstat、free、ps、top等&lt;/p&gt;&lt;p&gt;2.常用组合方式
vmstat、sar、iostat检测是否是CPU瓶颈
free、vmstat检测是否是内存瓶颈
iostat检测是否是磁盘I/O瓶颈
netstat检测是否是网络带宽瓶颈
2.1.4 Linux性能评估与优化
系统整体性能评估（uptime命令）
uptime&lt;/p&gt;&lt;p&gt;16:38:00 up 118 days, 3:01, 5 users,load average: 1.22, 1.02, 0.91&lt;/p&gt;&lt;p&gt;注意：&lt;/p&gt;&lt;p&gt;load average三值大小一般不能大于系统CPU的个数。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;系统有8个CPU,如load average三值长期大于8，说明CPU很繁忙，负载很高，可能会影响系统性能。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;但偶尔大于8，一般不会影响系统性能。&lt;/p&gt;&lt;p&gt;如load average输出值小于CPU个数，则表示CPU有空闲时间片，比如本例中的输出，CPU是非常空闲的&lt;/p&gt;&lt;p&gt;2.2.1 CPU性能评估
1.利用vmstat命令监控系统CPU
显示系统各种资源之间相关性能简要信息，主要看CPU负载情况。&lt;/p&gt;&lt;p&gt;下面是vmstat命令在某个系统的输出结果：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;[root@node1 ~]#vmstat 2 3&lt;/p&gt;&lt;p&gt;procs
 ———–memory———- —swap– —–io—- –system– —–cpu——&lt;/p&gt;&lt;p&gt;r  b swpd freebuff  cache si so bi bo incs us sy idwa st&lt;/p&gt;&lt;p&gt;0  0 0 162240 8304 67032 0 0 13 21 1007 23 0 1 98 0 0&lt;/p&gt;&lt;p&gt;0  0 0 162240 8304 67032 0 0 1 0 1010 20 0 1 100 0 0&lt;/p&gt;&lt;p&gt;0  0 0 162240 8304 67032 0 0 1 1 1009 18 0 1 99 0 0
Procs
r--运行和等待cpu时间片的进程数，这个值如果长期大于系统CPU的个数，说明CPU不足，需要增加CPU&lt;/p&gt;&lt;p&gt;b--在等待资源的进程数，比如正在等待I/O、或者内存交换等。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CPU
us
用户进程消耗的CPU 时间百分比。
us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，就需要考虑优化程序或算法。&lt;/p&gt;&lt;p&gt;sy
内核进程消耗的CPU时间百分比。Sy的值较高时，说明内核消耗的CPU资源很多。&lt;/p&gt;&lt;p&gt;根据经验，us+sy的参考值为80%，如果us+sy大于 80%说明可能存在CPU资源不足。&lt;/p&gt;&lt;p&gt;2.利用sar命令监控系统CPU
sar对系统每方面进行单独统计，但会增加系统开销，不过开销可以评估，对系统的统计结果不会有很大影响。&lt;/p&gt;&lt;p&gt;下面是sar命令对某个系统的CPU统计输出：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;[root@webserver ~]# sar -u 3 5&lt;/p&gt;&lt;p&gt;Linux
 2.6.9-42.ELsmp (webserver) 11/28/2008_i686_
 (8 CPU)&lt;/p&gt;&lt;p&gt;11:41:24
 AM CPU %user %nice%system
 %iowait %steal %idle&lt;/p&gt;&lt;p&gt;11:41:27
 AM all 0.88 0.00 0.29 0.00 0.00 98.83&lt;/p&gt;&lt;p&gt;11:41:30
 AM all 0.13 0.00 0.17 0.21 0.00 99.50&lt;/p&gt;&lt;p&gt;11:41:33
 AM all 0.04 0.00 0.04 0.00 0.00 99.92&lt;/p&gt;&lt;p&gt;11:41:36
 AM all 90.08 0.00 0.13 0.16 0.00 9.63&lt;/p&gt;&lt;p&gt;11:41:39
 AM all 0.38 0.00 0.17 0.04 0.00 99.41&lt;/p&gt;&lt;p&gt;Average:
 all 0.34 0.00 0.16 0.05 0.00 99.45&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;输出解释如下：&lt;/p&gt;&lt;p&gt;%user列显示了用户进程消耗的CPU 时间百分比。
%nice列显示了运行正常进程所消耗的CPU 时间百分比。
%system列显示了系统进程消耗的CPU时间百分比。
%iowait列显示了IO等待所占用的CPU时间百分比
%steal列显示了在内存相对紧张的环境下pagein强制对不同的页面进行的steal操作 。
%idle列显示了CPU处在空闲状态的时间百分比。
问题
你是否遇到过系统CPU整体利用率不高，而应用缓慢的现象？&lt;/p&gt;&lt;p&gt;在一个多CPU的系统中，如果程序使用了单线程，会出现这么一个现象，CPU的整体使用率不高，但是系统应用却响应缓慢，这可能是由于程序使用单线程的原因，单线程只使用一个CPU，导致这个CPU占用率为100%，无法处理其它请求，而其它的CPU却闲置，这就导致了整体CPU使用率不高，而应用缓慢现象的发生。&lt;/p&gt;&lt;p&gt;2.3.1 内存性能评估
1.利用free指令监控内存
free是监控Linux内存使用状况最常用的指令，看下面的一个输出：&lt;/p&gt;&lt;p&gt;[root@webserver ~]# free -m&lt;/p&gt;&lt;p&gt;total
 used freeshared
 buffers cached&lt;/p&gt;&lt;p&gt;Mem:
 8111 7185 926 0 243 6299&lt;/p&gt;&lt;p&gt;-/+
 buffers/cache:
 643 7468&lt;/p&gt;&lt;p&gt;Swap:
 8189 0 8189
经验公式：&lt;/p&gt;&lt;p&gt;应用程序可用内存/系统物理内存&amp;gt;70%，表示系统内存资源非常充足，不影响系统性能;
应用程序可用内存/系统物理内存&amp;lt;20%，表示系统内存资源紧缺，需要增加系统内存;
20%&amp;lt;应用程序可用内存/系统物理内存&amp;lt;70%，表示系统内存资源基本能满足应用需求，暂时不影响系统性能
2.利用vmstat命令监控内存
[root@node1
 ~]#
 vmstat 2 3&lt;/p&gt;&lt;p&gt;procs
 ———–memory———- —swap– —–io—- –system– —–cpu——&lt;/p&gt;&lt;p&gt;r b swpd freebuff cache si so bi bo incs us sy idwa st&lt;/p&gt;&lt;p&gt;0 0 0 162240 8304 67032 0 0 13 21 1007 23 0 1 98 0 0&lt;/p&gt;&lt;p&gt;0 0 0 162240 8304 67032 0 0 1 0 1010 20 0 1 100 0 0&lt;/p&gt;&lt;p&gt;0 0 0 162240 8304 67032 0 0 1 1 1009 18 0 1 99 0 0
memory&lt;/p&gt;&lt;p&gt;swpd--切换到内存交换区的内存数量（k为单位)。如swpd值偶尔非0，不影响系统性能
free--当前空闲的物理内存数量（k为单位）
buff--buffers cache的内存数量，一般对块设备的读写才需要缓冲
cache--page cached的内存数量
一般作为文件系统cached，频繁访问的文件都会被cached，如cache值较大，说明cached的文件数较多，如果此时IO中bi比较小，说明文件系统效率比较好。&lt;/p&gt;&lt;p&gt;swap&lt;/p&gt;&lt;p&gt;si--由磁盘调入内存，也就是内存进入内存交换区的数量。
so--由内存调入磁盘，也就是内存交换区进入内存的数量。
si、so的值长期不为0，表示系统内存不足。需增加系统内存。&lt;/p&gt;&lt;p&gt;2.4.1磁盘I/O性能评估
1.磁盘存储基础
频繁访问的文件或数据尽可能用内存读写代替直接磁盘I/O，效率高千倍。&lt;/p&gt;&lt;p&gt;将经常进行读写的文件与长期不变的文件独立出来，分别放置到不同的磁盘设备上。&lt;/p&gt;&lt;p&gt;对于写操作频繁的数据，可以考虑使用裸设备代替文件系统。&lt;/p&gt;&lt;p&gt;裸设备优点：&lt;/p&gt;&lt;p&gt;数据可直接读写，不需经过操作系统级缓存，节省内存资源，避免内存资源争用;
避免文件系统级维护开销，如文件系统需维护超级块、I-node等;
避免了操作系统cache预读功能，减少了I/O请求
使用裸设备的缺点是：&lt;/p&gt;&lt;p&gt;数据管理、空间管理不灵活，需要很专业的人来操作。&lt;/p&gt;&lt;p&gt;2.利用iostat评估磁盘性能
[root@webserver ~]# iostat -d 2 3&lt;/p&gt;&lt;p&gt;Linux
 2.6.9-42.ELsmp (webserver) 12/01/2008_i686_
 (8 CPU)&lt;/p&gt;&lt;p&gt;Device:
 tps Blk_read/sBlk_wrtn/sBlk_read
 Blk_wrtn&lt;/p&gt;&lt;p&gt;sda 1.87 2.58 114.12 6479462 286537372&lt;/p&gt;&lt;p&gt;Device:
 tps Blk_read/sBlk_wrtn/sBlk_read
 Blk_wrtn&lt;/p&gt;&lt;p&gt;sda
 0.00 0.00 0.00 0 0&lt;/p&gt;&lt;p&gt;Device:
 tps Blk_read/sBlk_wrtn/sBlk_read
 Blk_wrtn&lt;/p&gt;&lt;p&gt;sda
 1.00 0.00 12.00 0 24
解释如下：&lt;/p&gt;&lt;p&gt;Blk_read/s--每秒读取数据块数
Blk_wrtn/s--每秒写入数据块数
Blk_read--读取的所有块数
Blk_wrtn--写入的所有块数
可通过Blk_read/s和Blk_wrtn/s值对磁盘的读写性能有一个基本的了解.
如Blk_wrtn/s值很大，表示磁盘写操作频繁，考虑优化磁盘或程序，
如Blk_read/s值很大，表示磁盘直接读操作很多，可将读取的数据放入内存&lt;/p&gt;&lt;p&gt;规则遵循：&lt;/p&gt;&lt;p&gt;长期的、超大的数据读写，肯定是不正常的，这种情况一定会影响系统性能。&lt;/p&gt;&lt;p&gt;3.利用sar评估磁盘性能
通过“sar –d”组合，可以对系统的磁盘IO做一个基本的统计，请看下面的一个输出：&lt;/p&gt;&lt;p&gt;[root@webserver ~]# sar -d 2 3&lt;/p&gt;&lt;p&gt;Linux
 2.6.9-42.ELsmp (webserver) 11/30/2008_i686_
 (8 CPU)&lt;/p&gt;&lt;p&gt;11:09:33
 PM DEV tps rd_sec/swr_sec/savgrq-sz
 avgqu-sz await svctm %util&lt;/p&gt;&lt;p&gt;11:09:35
 PM dev8-0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00&lt;/p&gt;&lt;p&gt;11:09:35
 PM DEV tps rd_sec/swr_sec/savgrq-sz
 avgqu-sz await svctm %util&lt;/p&gt;&lt;p&gt;11:09:37
 PM dev8-0 1.00 0.00 12.00 12.00 0.00 0.00 0.00 0.00&lt;/p&gt;&lt;p&gt;11:09:37
 PM DEV tps rd_sec/swr_sec/savgrq-sz
 avgqu-sz await svctm %util&lt;/p&gt;&lt;p&gt;11:09:39
 PM dev8-0 1.99 0.00 47.76 24.00 0.00 0.50 0.25 0.05&lt;/p&gt;&lt;p&gt;Average:
 DEV tps rd_sec/swr_sec/savgrq-sz
 avgqu-sz await svctm %util&lt;/p&gt;&lt;p&gt;Average:
 dev8-0 1.00 0.00 19.97 20.00 0.00 0.33 0.17 0.02
参数含义：&lt;/p&gt;&lt;p&gt;await--平均每次设备I/O操作等待时间（毫秒）
svctm--平均每次设备I/O操作的服务时间（毫秒）
%util--一秒中有百分之几的时间用于I/O操作
对磁盘IO性能评判标准：&lt;/p&gt;&lt;p&gt;正常svctm应小于await值，而svctm和磁盘性能有关，CPU、内存负荷也会对svctm值造成影响，过多的请求也会间接的导致svctm值的增加。&lt;/p&gt;&lt;p&gt;await值取决svctm和I/O队列长度以及I/O请求模式，
如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，
如果await的值远高于svctm的值，则表示I/O队列等待太长，系统上运行的应用程序将变慢，
此时可以通过更换更快的硬盘来解决问题。
%util--衡量磁盘I/O重要指标，&lt;/p&gt;&lt;p&gt;如%util接近100%，表示磁盘产生的I/O请求太多，I/O系统已经满负荷工作，该磁盘可能存在瓶颈。&lt;/p&gt;&lt;p&gt;可优化程序或者 通过更换 更高、更快的磁盘。&lt;/p&gt;&lt;p&gt;2.5.1. 网络性能评估
（1）通过ping命令检测网络的连通性
（2）通过netstat –i组合检测网络接口状况
（3）通过netstat –r组合检测系统的路由表信息
（4）通过sar –n组合显示系统的网络运行状态
三 Linux服务器性能调优
1.为磁盘I/O调整Linux内核电梯算法
选择文件系统后，该算法可以平衡低延迟需求，收集足够数据，有效组织对磁盘读写请求。&lt;/p&gt;&lt;p&gt;2.禁用不必要的守护进程，节省内存和CPU资源
许多守护进程或服务通常非必需，消耗宝贵内存和CPU时间。将服务器置于险地。
禁用可加快启动时间，释放内存。&lt;/p&gt;&lt;p&gt;减少CPU要处理的进程数
一些应被禁用的Linux守护进程，默认自动运行：&lt;/p&gt;&lt;p&gt;序号 守护进程 描述
1 Apmd 高级电源管理守护进程
2 Nfslock 用于NFS文件锁定
3 Isdn ISDN Moderm支持
4 Autofs 在后台自动挂载文件系统(如自动挂载CD-ROM)
5 Sendmail 邮件传输代理
6 Xfs X Window的字体服务器&lt;/p&gt;&lt;p&gt;3.关掉GUI
4、清理不需要的模块或功能
服务器软件包中太多被启动的功能或模块实际上是不需要的(如Apache中的许多功能模块)，禁用掉有助于提高系统内存可用量，腾出资源给那些真正需要的软件，让它们运行得更快。&lt;/p&gt;&lt;p&gt;5、禁用控制面板
在Linux中，有许多流行的控制面板，如Cpanel，Plesk，Webmin和phpMyAdmin等，禁用释放出大约120MB内存，内存使用量大约下降30-40%。&lt;/p&gt;&lt;p&gt;6、改善Linux Exim服务器性能
使用DNS缓存守护进程，可降低解析DNS记录需要的带宽和CPU时间，DNS缓存通过消除每次都从根节点开始查找DNS记录的需求，从而改善网络性能。&lt;/p&gt;&lt;p&gt;Djbdns是一个非常强大的DNS服务器，它具有DNS缓存功能，Djbdns比BIND DNS服务器更安全，性能更好，可以直接通过&lt;a href="http://cr.yp.to/%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%96%E9%80%9A%E8%BF%87Red"&gt;http://cr.yp.to/%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%96%E9%80%9A%E8%BF%87Red&lt;/a&gt; Hat提供的软件包获得。&lt;/p&gt;&lt;p&gt;7、使用AES256增强gpg文件加密安全
为提高备份文件或敏感信息安全，许多Linux系统管理员都使用gpg进行加密，在使用gpg时，最好指定gpg使用AES256加密算法，AES256使用256位密钥，它是一个开放的加密算法，美国国家安全局(NSA)使用它保护绝密信息。&lt;/p&gt;&lt;p&gt;8、远程备份服务安全
安全是选择远程备份服务最重要的因素，大多数系统管理员都害怕两件事：(黑客)可以删除备份文件，不能从备份恢复系统。&lt;/p&gt;&lt;p&gt;为了保证备份文件100%的安全，备份服务公司提供远程备份服务器，使用scp脚本或RSYNC通过SSH传输数据，这样，没有人可以直接进入和访问远程系统，因此，也没有人可以从备份服务删除数据。在选择远程备份服务提供商时，最好从多个方面了解其服务强壮性，如果可以，可以亲自测试一下。&lt;/p&gt;&lt;p&gt;9、更新默认内核参数设置
为了顺利和成功运行企业应用程序，如数据库服务器，可能需要更新一些默认的内核参数设置，例如，2.4.x系列内核消息队列参数msgmni有一个默认值(例如，共享内存，或shmmax在Red Hat系统上默认只有33554432字节)，它只允许有限的数据库并发连接，下面为数据库服务器更好地运行提供了一些建议值(来自IBM DB2支持网站)：&lt;/p&gt;&lt;p&gt;kernel.shmmax=268435456 (32位)
kernel.shmmax=1073741824 (64位)
kernel.msgmni=1024
fs.file-max=8192
kernel.sem=”250 32000 32 1024″&lt;/p&gt;&lt;p&gt;10、优化TCP
优化TCP协议有助于提高网络吞吐量，跨广域网的通信使用的带宽越大，延迟时间越长时，建议使用越大的TCP Linux大小，以提高数据传输速率，TCP Linux大小决定了发送主机在没有收到数据传输确认时，可以向接收主机发送多少数据。&lt;/p&gt;&lt;p&gt;11、选择正确的文件系统
使用ext4文件系统取代ext3&lt;/p&gt;&lt;p&gt;● Ext4是ext3文件系统的增强版，扩展了存储限制&lt;/p&gt;&lt;p&gt;●具有日志功能，保证高水平的数据完整性(在非正常关闭事件中)&lt;/p&gt;&lt;p&gt;●非正常关闭和重启时，它不需要检查磁盘(这是一个非常耗时的动作)&lt;/p&gt;&lt;p&gt;●更快的写入速度，ext4日志优化了硬盘磁头动作&lt;/p&gt;&lt;p&gt;12、使用noatime文件系统挂载选项
在文件系统启动配置文件fstab中使用noatime选项，如果使用了外部存储，这个挂载选项可以有效改善性能。&lt;/p&gt;&lt;p&gt;13、调整Linux文件描述符限制
Linux限制了任何进程可以打开的文件描述符数量，默认限制是每进程1024，这些限制可能会阻碍基准测试客户端(如httperf和apachebench)和Web服务器本身获得最佳性能，Apache每个连接使用一个进程，因此不会受到影响，但单进程Web服务器，如Zeus是每连接使用一个文件描述符，因此很容易受默认限制的影响。&lt;/p&gt;&lt;p&gt;打开文件限制是一个可以用ulimit命令调整的限制，ulimit -aS命令显示当前的限制，ulimit -aH命令显示硬限制(在未调整/proc中的内核参数前，你不能增加限制)。&lt;/p&gt;&lt;p&gt;Linux第三方应用程序性能技巧&lt;/p&gt;&lt;p&gt;对于运行在Linux上的第三方应用程序，一样有许多性能优化技巧，这些技巧可以帮助你提高Linux服务器的性能，降低运行成本。&lt;/p&gt;&lt;p&gt;14、正确配置MySQL
为了给MySQL分配更多的内存，可设置MySQL缓存大小，要是MySQL服务器实例使用了更多内存，就减少缓存大小，如果MySQL在请求增多时停滞不动，就增加MySQL缓存。&lt;/p&gt;&lt;p&gt;15、正确配置Apache
检查Apache使用了多少内存，再调整StartServers和MinSpareServers参数，以释放更多的内存，将有助于你节省30-40%的内存。&lt;/p&gt;&lt;p&gt;16、分析Linux服务器性能
提高系统效率最好的办法是找出导致整体速度下降的瓶颈并解决掉，下面是找出系统关键瓶颈的一些基本技巧：&lt;/p&gt;&lt;p&gt;● 当大型应用程序，如OpenOffice和Firefox同时运行时，计算机可能会开始变慢，内存不足的出现几率更高。&lt;/p&gt;&lt;p&gt;● 如果启动时真的很慢，可能是应用程序初次启动需要较长的加载时间，一旦启动好后运行就正常了，否则很可能是硬盘太慢了。&lt;/p&gt;&lt;p&gt;●CPU负载持续很高，内存也够用，但CPU利用率很低，可以使用CPU负载分析工具监控负载时间。&lt;/p&gt;&lt;p&gt;17、学习5个Linux性能命令
使用几个命令就可以管理Linux系统的性能了，下面列出了5个最常用的Linux性能命令，包括
top、vmstat、iostat、free和sar，它们有助于系统管理员快速解决性能问题。&lt;/p&gt;&lt;p&gt;(1)top
当前内核服务的任务，还显示许多主机状态的统计数据，默认情况下，它每隔5秒自动更新一次。
如：当前正常运行时间，系统负载，进程数量和内存使用率，&lt;/p&gt;&lt;p&gt;此外，这个命令也显示了那些使用最多CPU时间的进程(包括每个进程的各种信息，如运行用户，执行的命令等)。&lt;/p&gt;&lt;p&gt;(2)vmstat
Vmstat命令提供当前CPU、IO、进程和内存使用率的快照，它和top命令类似，自动更新数据，如：&lt;/p&gt;&lt;p&gt;$ vmstat 10&lt;/p&gt;&lt;p&gt;(3)iostat
Iostat提供三个报告：CPU利用率、设备利用率和网络文件系统利用率，使用-c，-d和-h参数可以分别独立显示这三个报告。&lt;/p&gt;&lt;p&gt;(4)free
显示主内存和交换空间内存统计数据，指定-t参数显示总内存，指定-b参数按字节为单位，使用-m则以兆为单位，默认情况下千字节为单位。&lt;/p&gt;&lt;p&gt;Free命令也可以使用-s参数加一个延迟时间(单位：秒)连续运行，如：&lt;/p&gt;&lt;p&gt;$ free -s 5&lt;/p&gt;&lt;p&gt;(5)sar
收集，查看和记录性能数据，这个命令比前面几个命令历史更悠久，它可以收集和显示较长周期的数据。&lt;/p&gt;&lt;p&gt;其它&lt;/p&gt;&lt;p&gt;下面是一些归类为其它的性能技巧：&lt;/p&gt;&lt;p&gt;18、将日志文件转移到内存中
当一台机器处于运行中时，最好是将系统日志放在内存中，当系统关闭时再将其复制到硬盘，当你运行一台开启了syslog功能的笔记本电脑或移动设备时，ramlog可以帮助你提高系统电池或移动设备闪存驱动器的寿命，使用ramlog的一个好处是，不用再担心某个守护进程每隔30秒向syslog发送一条消息，放在以前，硬盘必须随时保持运转，这样对硬盘和电池都不好。&lt;/p&gt;&lt;p&gt;19、先打包，后写入
在内存中划分出固定大小的空间保存日志文件，这意味着笔记本电脑硬盘不用一直保持运转，只有当某个守护进程需要写入日志时才运转，注意ramlog使用的内存空间大小是固定的，否则系统内存会很快被用光，如果笔记本使用固态硬盘，可以分配50-80MB内存给ramlog使用，ramlog可以减少许多写入周期，极大地提高固态硬盘的使用寿命。&lt;/p&gt;&lt;p&gt;20、一般调优技巧
尽可能使用静态内容替代动态内容，如果你在生成天气预告，或其它每隔1小时就必须更新的数据，最好是写一个程序，每隔1小时生成一个静态的文件，而不是让用户运行一个CGI动态地生成报告。&lt;/p&gt;&lt;p&gt;为动态应用程序选择最快最合适的API，CGI可能最容易编程，但它会为每个请求产生一个进程，通常，这是一个成本很高，且不必要的过程，FastCGI是更好的选择，和Apache的mod_perl一样，都可以极大地提高应用程序的性能。&lt;/p&gt;</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/Linux%E6%80%A7%E8%83%BD%E6%9F%A5%E7%9C%8B/</guid><pubDate>Sat, 27 Nov 2021 00:00:00 +0806</pubDate></item><item><title>Tracking指标</title><link>/Blog/archives/Tracking%E6%8C%87%E6%A0%87/</link><description>&lt;h2&gt;评价标准&lt;/h2&gt;
&lt;p&gt;True positives（TP，真正） : 预测为正，实际为正&lt;/p&gt;&lt;p&gt;True negatives（TN，真负）：预测为负，实际为负&lt;/p&gt;&lt;p&gt;False positives（FP，假正）: 预测为正，实际为负&lt;/p&gt;&lt;p&gt;False negatives（FN，假负）：预测为负，实际为正&lt;/p&gt;&lt;figure style="flex: 28.37837837837838" &gt;&lt;img width="441" height="777" src="https://pic1.zhimg.com/80/v2-ede11a19f93d09e20039bb77a0a9cf90_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;TPR、FPR和TNR&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TPR&lt;/strong&gt;（true positive rate，真正类率，灵敏度，Sensitivity）&lt;/p&gt;&lt;p&gt;TPR = TP/(TP+FN)&lt;/p&gt;&lt;p&gt;真正类率TPR代表分类器预测的正类中实际正实例占所有正实例的比例。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;FPR&lt;/strong&gt;（false positive rate，假正类率）&lt;/p&gt;&lt;p&gt;FPR = FP/(FP+TN)&lt;/p&gt;&lt;p&gt;假正类率FPR代表分类器预测的正类中实际负实例占所有负实例的比例。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TNR&lt;/strong&gt;（ture negative rate，真负类率，特异度，Specificity）&lt;/p&gt;&lt;p&gt;TNR = TN/(FP+TN)
TNR = 1 - FPR&lt;/p&gt;&lt;p&gt;真负类率TNR代表分类器预测的负类中实际负实例占所有负实例的比例。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Recall&lt;/strong&gt; = TPR（召回率）&lt;/p&gt;&lt;p&gt;Recall = TP/（TP+FN）&lt;/p&gt;&lt;p&gt;即当前被分到正样本类别中，真实的正样本占所有正样本的比例，即召回率（召回了多少正样本比例）；&lt;strong&gt;（召回率表示真正预测为正样本的样本数占实际正样本的样本数的比率）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Precision&lt;/strong&gt;（精确率）&lt;/p&gt;&lt;p&gt;Pre = TP/（TP+FP）&lt;/p&gt;&lt;p&gt;当前预测为正样本类别中，被正确分类的比例（即正式正样本所占比例），就是我们一般理解意义上所关心的正样本的分类精确率确率；&lt;strong&gt;（精确率表示真正预测为正样本的样本数占所有预测为正样本的样本数的比例）&lt;/strong&gt; 通俗说：预测为正样本中正确的占的比例&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Accuracy&lt;/strong&gt;（准确率，ACC）&lt;/p&gt;&lt;p&gt;ACC = (TP+TN)/(TP+TN+FN+FP)&lt;/p&gt;&lt;p&gt;表示预测正确的样本占所有样本的比率&lt;/p&gt;&lt;p&gt;&lt;strong&gt;F-Score&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;F-Score 是精确率Precision和召回率Recall的加权调和平均值。该值是为了综合衡量Precision和Recall而设定的。&lt;/p&gt;&lt;figure style="flex: 145.4198473282443" &gt;&lt;img width="381" height="131" src="https://pic4.zhimg.com/80/v2-0f76e89f7b9b09e1666655ff0553c5cb_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当a=1时，&lt;/p&gt;&lt;figure style="flex: 133.1818181818182" &gt;&lt;img width="293" height="110" src="https://pic3.zhimg.com/80/v2-e0e13bd5e4f486fda7562cc836b96676_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这时，Precision和Recall都很重要，权重相同。&lt;/p&gt;&lt;p&gt;当有些情况下，我们认为Precision更重要，那就调整a的值小于1；如果我们认为Recall更加重要，那就调整a的值大于1。&lt;/p&gt;&lt;p&gt;一般来说，当F-Score或F1-score较高时，说明结果较理想。&lt;/p&gt;&lt;h3&gt;ROC&lt;/h3&gt;
&lt;figure style="flex: 102.92553191489361" &gt;&lt;img width="774" height="376" src="https://pic1.zhimg.com/80/v2-4dbeb108d5d8349a9e4ab062ca926d74_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;横轴FPR:1-TNR,1-Specificity，FPR越大，预测正类中实际负类越多。&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.zhihu.com/search?q=%E7%BA%B5%E8%BD%B4TPR&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;纵轴TPR&lt;/a&gt;：Sensitivity(正类覆盖率),TPR越大，预测正类中实际正类越多。&lt;/p&gt;&lt;p&gt;理想目标：TPR=1，FPR=0,即图中(0,1)点，故ROC曲线越靠拢(0,1)点，越偏离45度&lt;a href="https://www.zhihu.com/search?q=%E5%AF%B9%E8%A7%92%E7%BA%BF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;对角线&lt;/a&gt;越好，Sensitivity、Specificity越大效果越好。&lt;/p&gt;&lt;h3&gt;ROC绘制&lt;/h3&gt;
&lt;p&gt;ROC本质上就是在设定某一阈值之后，计算出该阈值对应的TPR &amp;amp; FPR，便可以绘制出ROC上对应的一个点，当设定若干个阈值之后，便可以连成ROC曲线，因此可以想见，当所采样的阈值越多，ROC Curve越平滑。&lt;/p&gt;&lt;h3&gt;如何画&lt;a href="https://www.zhihu.com/search?q=roc%E6%9B%B2%E7%BA%BF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;roc曲线&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;假设已经得出一系列样本被划分为正类的概率，然后按照大小排序，下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。&lt;/p&gt;&lt;figure style="flex: 59.55473098330241" &gt;&lt;img width="642" height="539" src="https://pic4.zhimg.com/80/v2-2e7ccbea8660960971fe9fcb27eb4e47_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;接下来，我们从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：&lt;/p&gt;&lt;figure style="flex: 61.21399176954733" &gt;&lt;img width="595" height="486" src="https://pic2.zhimg.com/80/v2-6dfd4a7c5a0a185ebf91727dbccad86d_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;AUC(Area under Curve)：Roc曲线下的面积，介于0.1和1之间。Auc作为数值可以直观的评价分类器的好坏，值越大越好。&lt;/p&gt;&lt;h3&gt;AUC&lt;/h3&gt;
&lt;p&gt;AUC 即ROC曲线下的面积，计算方式即为ROC Curve的微积分值，其物理意义可以表示为：随机给定一正一负两个样本，将正样本排在负样本之前的概率，因此AUC越大，说明正样本越有可能被排在负样本之前，即分类额结果越好。&lt;/p&gt;&lt;p&gt;AUC(Area under Curve)：Roc曲线下的面积，介于0.1和1之间。Auc作为数值可以直观的评价分类器的好坏，值越大越好。&lt;/p&gt;&lt;h3&gt;为什么使用Roc和Auc评价分类器&lt;/h3&gt;
&lt;p&gt;ROC曲线有个很好的特性：当测试集中的正负样本的分布变换的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现样本类不平衡，即正负样本比例差距较大，而且测试数据中的正负样本也可能随着时间变化。下图是ROC曲线和&lt;a href="https://www.zhihu.com/search?q=Presision-Recall%E6%9B%B2%E7%BA%BF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;Presision-Recall曲线&lt;/a&gt;的对比：&lt;/p&gt;&lt;figure style="flex: 56.193078324225866" &gt;&lt;img width="617" height="549" src="https://pic2.zhimg.com/80/v2-abf8d5303be1e91aa968432ad5d40d5d_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在上图中，(a)和(c)为&lt;a href="https://www.zhihu.com/search?q=Roc%E6%9B%B2%E7%BA%BF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;Roc曲线&lt;/a&gt;，(b)和(d)为Precision-Recall曲线。&lt;/p&gt;&lt;p&gt;(a)和(b)展示的是分类其在原始测试集(&lt;a href="https://www.zhihu.com/search?q=%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;正负样本&lt;/a&gt;分布平衡)的结果，(c)(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果，可以明显的看出，ROC曲线基本保持原貌，而Precision-Recall曲线变化较大。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解读&lt;/strong&gt;：&lt;strong&gt;ROC曲线围成的面积 (即AUC)可以解读为：从所有正例中随机选取一个样本A，再从所有负例中随机选取一个样本B，分类器将A判为正例的概率比将B判为正例的概率大的可能性。可以看到位于随机线上方的点(如图中的A点)被认为好于随机猜测。在这样的点上TPR总大于FPR，意为正例被判为正例的概率大于负例被判为正例的概率&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;从另一个角度看，由于画ROC曲线时都是先将所有样本按分类器的预测概率排序，所以AUC反映的是分类器对样本的排序能力，依照上面的例子就是A排在B前面的概率。AUC越大，自然排序能力越好，即分类器将越多的正例排在负例之前。&lt;/p&gt;&lt;h3&gt;ROC的相关总结&lt;/h3&gt;
&lt;p&gt;1） ROC 可以反映二分类器的总体分类性能，但是无法直接从图中识别出分类最好的阈值，事实上最好的阈值也是视具体的场景所定；&lt;/p&gt;&lt;p&gt;2）ROC Curve 对应的AUC越大（或者说对于连续凸函数的ROC曲线越接近(0,1) )说明分类性能越好;&lt;/p&gt;&lt;p&gt;3）ROC曲线一定是需要在 y = x之上的，否则就是一个不理想的分类器；&lt;/p&gt;&lt;h3&gt;ROC曲线的优点&lt;/h3&gt;
&lt;p&gt;放一张混淆矩阵图可能看得更清楚一点 :&lt;/p&gt;&lt;figure style="flex: 108.0078125" &gt;&lt;img width="553" height="256" src="https://pic4.zhimg.com/80/v2-e76f65e7a0a42f51b4dcc0169157660f_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;兼顾&lt;a href="https://www.zhihu.com/search?q=%E6%AD%A3%E4%BE%8B&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;正例&lt;/a&gt;和负例的权衡。因为TPR聚焦于正例，FPR聚焦于与负例，使其成为一个比较均衡的评估方法。&lt;/p&gt;&lt;p&gt;ROC曲线选用的两个指标，TPR=TPP=TPTP+&lt;a href="https://www.zhihu.com/search?q=FNTPR%3DTPP%3DTPTP%2BFN&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;FNTPR=TPP=TPTP+FN&lt;/a&gt;，FPR=FPN=FPFP+TNFPR=FPN=FPFP+TN，都&lt;strong&gt;不依赖于具体的类别分布&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;注意TPR用到的TP和FN同属P列，FPR用到的FP和TN同属N列，所以即使P或N的整体数量发生了改变，也不会影响到另一列。也就是说，&lt;strong&gt;即使正例与负例的比例发生了很大变化，ROC曲线也不会产生大的变化，而像Precision使用的TP和FP就分属两列，则易受类别分布改变的影响&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;参考文献 [1] 中举了个例子，负例增加了10倍，ROC曲线没有改变，而PR曲线则变了很多。作者认为这是ROC曲线的优点，即具有&lt;a href="https://www.zhihu.com/search?q=%E9%B2%81%E6%A3%92%E6%80%A7&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A87768945%7D"&gt;鲁棒性&lt;/a&gt;，在类别分布发生明显改变的情况下依然能客观地识别出较好的分类器。&lt;/p&gt;&lt;figure style="flex: 54.33839479392625" &gt;&lt;img width="501" height="461" src="https://pic2.zhimg.com/80/v2-1315348b974d74f468cccee1a6452765_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;ROC曲线的缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;上文提到ROC曲线的优点是不会随着类别分布的改变而改变，但这在某种程度上也是其缺点&lt;/strong&gt;。因为负例N增加了很多，而曲线却没变，这等于产生了大量FP。像信息检索中如果主要关心正例的预测准确性的话，这就不可接受了。&lt;/p&gt;&lt;p&gt;在类别不平衡的背景下，负例的数目众多致使FPR的增长不明显，导致ROC曲线呈现一个过分乐观的效果估计。ROC曲线的横轴采用FPR，根据FPR =FPNFPN=FPFP+TNFPFP+TN，&lt;strong&gt;当负例N的数量远超正例P时，FP的大幅增长只能换来FPR的微小改变。结果是虽然大量负例被错判成正例，在ROC曲线上却无法直观地看出来&lt;/strong&gt;。（当然也可以只分析ROC曲线左边一小段） 举个例子，假设一个数据集有正例20，负例10000，开始时有20个负例被错判，FPR=2020+9980=0.002FPR=2020+9980=0.002，接着又有20个负例错判，FPR2=4040+9960=0.004FPR2=4040+9960=0.004，在ROC曲线上这个变化是很细微的。而与此同时Precision则从原来的0.5下降到了0.33，在PR曲线上将会是一个大幅下降。&lt;/p&gt;&lt;h3&gt;PR曲线&lt;/h3&gt;
&lt;p&gt;在PR曲线中，以Recall（貌似翻译为召回率或者查全率）为x轴，Precision为y轴。&lt;/p&gt;&lt;figure style="flex: 64.93362831858407" &gt;&lt;img width="587" height="452" src="https://pic4.zhimg.com/80/v2-331a4faabbfccdb904b44b3fd20dbf93_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;绘制ROC曲线和PR曲线都是选定不同阈值，从而得到不同的x轴和y轴的值，画出曲线。&lt;/p&gt;&lt;h3&gt;PR (Precision Recall) 曲线&lt;/h3&gt;
&lt;p&gt;PR曲线展示的是Precision vs Recall的曲线，PR曲线与ROC曲线的相同点是都采用了TPR (Recall)，都可以用AUC来衡量分类器的效果。不同点是ROC曲线使用了FPR，而PR曲线使用了Precision，因此PR曲线的两个指标都聚焦于正例。类别不平衡问题中由于主要关心正例，所以在此情况下PR曲线被广泛认为优于ROC曲线。&lt;/p&gt;&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;ROC曲线由于兼顾正例与负例，所以适用于评估分类器的整体性能，相比而言PR曲线完全聚焦于正例。&lt;/p&gt;&lt;p&gt;如&lt;strong&gt;果有多份数据且存在不同的类别分布&lt;/strong&gt;，比如信用卡欺诈问题中每个月正例和负例的比例可能都不相同，&lt;strong&gt;这时候如果只想单纯地比较分类器的性能且剔除类别分布改变的影响，则ROC曲线比较适合&lt;/strong&gt;，因为类别分布改变可能使得PR曲线发生变化时好时坏，这种时候难以进行模型比较；反之，如果想测试相同类别分布下对分类器的性能的影响，则PR曲线比较适合。&lt;/p&gt;&lt;p&gt;如果想要评估在&lt;strong&gt;相同的类别分布下正例的预测情况，则宜选PR曲线&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;类别不平衡问题中，ROC曲线通常会给出一个乐观的效果估计，所以大部分时候还是PR曲线更好。&lt;/p&gt;&lt;p&gt;最后可以根据具体的应用，在曲线上找到最优的点，得到相对应的precision，recall，f1 score等指标，去调整模型的阈值，从而得到一个符合具体应用的模型。&lt;/p&gt;&lt;h3&gt;IoU&lt;/h3&gt;
&lt;p&gt;IoU这一值，可以理解为系统预测出来的框与原来图片中标记的框的重合程度。&lt;/p&gt;&lt;p&gt;计算方法即检测结果Detection Result与 Ground Truth 的交集比上它们的并集，即为检测的准确率：&lt;/p&gt;&lt;figure style="flex: 408.97435897435895" &gt;&lt;img width="319" height="39" src="https://pic3.zhimg.com/80/v2-53fd9c13a7e5e4c65bd48ece17a60632_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure style="flex: 241.02564102564102" &gt;&lt;img width="188" height="39" src="https://pic2.zhimg.com/80/v2-44ef24919ccbecd843290d80d6a94b3d_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如下图所示：
蓝色的框是：GroundTruth
黄色的框是：DetectionResult
绿色的框是：DetectionResult ⋂ GroundTruth
红色的框是：DetectionResult ⋃ GroundTruth&lt;/p&gt;&lt;figure style="flex: 60.557432432432435" &gt;&lt;img width="717" height="592" src="https://pic2.zhimg.com/80/v2-5a0e66ccee3063dbe4b7efba889f21c9_720w.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/Tracking%E6%8C%87%E6%A0%87/</guid><pubDate>Sat, 04 Dec 2021 00:00:00 +0806</pubDate></item><item><title>数字信号处理复习</title><link>/Blog/archives/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/</link><description>&lt;p&gt;&lt;strong&gt;数字信号处理复习&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;重要公式离散转模拟
$$
x[n] = sin(\omega &lt;em&gt;{0}n+\theta)=x&lt;/em&gt;{a}(nT_{s})=sin(2\pi f_{0}nT_{s}+\theta)
$$
具有周期性的正弦序列满足&lt;/p&gt;&lt;p&gt;$$
\omega _{0} = 2\pi \frac{M}{N}, M,N \in Z
$$&lt;/p&gt;
&lt;p&gt;在离散时间中$0\le \omega &amp;lt;2\pi$，其他是混叠的&lt;/p&gt;&lt;p&gt;DTFT：对离散时间的傅里叶变换，转换到频域中去，是连续的&lt;/p&gt;&lt;p&gt;对DTFT得到的频域序列进行采样，再取周期序列的主值空间，得到的便是DFT（离散傅里叶变换），方便计算机计算&lt;/p&gt;&lt;p&gt;这样IDFT得到的便是时域的周期延拓，==频域采样，时域周期延拓；时域采样，频域周期延拓==&lt;/p&gt;&lt;p&gt;DFS与DFT本质一致，DFS = 周期性序列一个周期的DFT&lt;/p&gt;&lt;p&gt;$n &amp;lt; 0 时 x[n] = 0$的序列称为因果序列。&lt;/p&gt;&lt;p&gt;线性移不变系统稳定的充分必要条件是其单位冲激响应绝对可和
$$
\sum_{n=-\infin}^{\infin} |h[n]| = P &amp;lt; \infin
$$
==FT变换公式==
$$
X(f)=\int_{-\infin}^{\infin}x(t)e^{-j2\pi ft}dt\
x(t)=\int_{-\infin}^{\infin}X(f)e^{j2\pi ft}df
$$
另外一种表达形式：$\Omega = 2\pi f$
$$
X(j\Omega )=\int_{-\infin}^{\infin}x(t)e^{-j\Omega t}dt\
x(t)=\frac{1}{2\pi}\int_{-\infin}^{\infin}X(j\Omega )e^{j\Omega t}d\Omega
$$
==重要例子==
$$
\Phi(f)=\frac{1}{F_{s}}rect(\frac{f}{F_{s}})\
\psi(t)=sinc(\frac{t}{T_{s}})
$$
插值应该是无限可微的&lt;/p&gt;&lt;p&gt;多项式插值&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;[ ] 拉格朗日插值函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
L_n^{(N)}(t) = \prod_{k=-N\ and\ k\ne n}^{N}\frac{t-k}{n-k}, n=-N,...,N \\
p(t) = \sum_{n=-N}^{N}x[n]L_n^{(N)}(t)
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重要特征：无限可微&lt;/li&gt;
&lt;li&gt;缺点：拉格朗日插值函数定义依赖于N，如果数据长度改变，多项式改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不要求无限可微，可采用核函数插值法，零阶插值、一阶插值、三阶插值……
$$
\lim_{N\rightarrow \infin} L_n^{(N)}(t) = sinc(t-n) 
$$
混叠公式&lt;/p&gt;&lt;figure style="flex: 93.9882697947214" &gt;&lt;img width="641" height="341" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/017c6c41c682f1f6353231b29c70c94a.png" /&gt;&lt;/figure&gt;&lt;p&gt;使用==低通滤波==将信号变成==带限信号==&lt;/p&gt;&lt;p&gt;采样时每隔$T_s$关闭一次开关，采样一次&lt;/p&gt;&lt;p&gt;信号流图上乘除上系数&lt;/p&gt;&lt;p&gt;不完备空间的例子：有理数集合
$$
x_{n}=\sum_{k=0}^{n} \frac{1}{k!} \in Q ~~ but~~ \lim_{n\rightarrow \infin}x_{n}=e\notin Q
$$
找到基函数&lt;/p&gt;&lt;figure style="flex: 66.9218989280245" &gt;&lt;img width="874" height="653" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/c0f34d7d3b52a0ccb61a0b3253cf27a5.png" /&gt;&lt;/figure&gt;&lt;p&gt;找到正交基前的系数，便是DFT的过程&lt;/p&gt;&lt;p&gt;近似空间&lt;/p&gt;&lt;figure style="flex: 95.45454545454545" &gt;&lt;img width="630" height="330" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/90a58da53f2bb907b44f83ac944f9b47.png" /&gt;&lt;/figure&gt;&lt;p&gt;正交投影是“最优”近似，有着最小范数误差&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;[ ] sinc采样的==空间解释==&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;STFT用窗取一段信号进行DFT&lt;/p&gt;&lt;p&gt;DFT定义
$$
w_k[n]=e^{j\frac{2\pi}{N}nk},~~n,k=0,1,...,N-1
$$
用这个基去表示x[n]&lt;/p&gt;&lt;p&gt;DFT在幅度上是对称的&lt;/p&gt;&lt;p&gt;采样要先限制在$F_{s}/2$内&lt;/p&gt;&lt;p&gt;或者先进行$F_{S}$-滤波&lt;/p&gt;</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/</guid><pubDate>Wed, 15 Dec 2021 00:00:00 +0806</pubDate></item><item><title>cage安装</title><link>/Blog/archives/cage%E5%AE%89%E8%A3%85/</link><description>&lt;p&gt;&lt;strong&gt;cage&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;已解决&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;安装时指定prefix采用绝对路径&lt;/p&gt;&lt;p&gt;现在寻找Cmake文件出错，安装出了问题&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;新问题&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;/home/pyc/Program/Thea_build/Thea/Code/Source/Plugins/GL/glxew.h:103:12: fatal error: GL/glew.h: No such file or directory&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺少的lib&lt;/strong&gt;：&lt;code&gt;apt-get install libglew-dev&lt;/code&gt;&lt;/p&gt;&lt;p&gt;方法&lt;/p&gt;&lt;figure style="flex: 140.20618556701032" &gt;&lt;img width="1088" height="388" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/62c37356a283538e7584e74b25b3ce1b.png" /&gt;&lt;/figure&gt;&lt;p&gt;下载文件过大&lt;/p&gt;&lt;figure style="flex: 53.01271420674406" &gt;&lt;img width="1918" height="1809" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/312a0c9f8801a0bde6e153072ac51234.png" /&gt;&lt;/figure&gt;&lt;p&gt;文件下载OK&lt;/p&gt;&lt;p&gt;文件含义问题&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;[x] picked文件读取的csv中shape=10的含义，没有picked文件默认为SMPL模型否则需要对应的picker文件，用于对应&lt;/li&gt;
&lt;li&gt;[ ] mean_value_coordinates如何计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码阅读&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;训练好的模型中含有cage和source（猜想为template）&lt;/li&gt;
&lt;/ul&gt;
</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/cage%E5%AE%89%E8%A3%85/</guid><pubDate>Fri, 17 Dec 2021 00:00:00 +0806</pubDate></item><item><title>天气之子</title><link>/Blog/archives/thesonofwhether/</link><description>&lt;p&gt;&lt;strong&gt;天气之子&lt;/strong&gt;&lt;/p&gt;&lt;figure style="flex: 28.125" &gt;&lt;img width="2160" height="3840" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/009096e3f6d30c23d806b2285816e09c.jpg" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;画面、音乐都是唯美含蓄。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这些都不重要，有你在身边就够了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能让人放弃对天气，不，是对世界的执念。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这不是一件本身就比那束光还暖还亮，男主一直追寻的那道光的尽头的答案吗？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大部分影片都是处于留白，留下无尽的想象。自己的感受就是一个青年从懵懂慢慢地走向成长，要承担自己的责任，为自己所爱的事物去不断努力，男生莽撞，女生担负着照顾其他的职责。&lt;/p&gt;&lt;p&gt;不断地成长吧！为了自己的以后。&lt;/p&gt;</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/thesonofwhether/</guid><pubDate>Thu, 23 Dec 2021 00:00:00 +0806</pubDate></item><item><title>李群和李代数</title><link>/Blog/archives/rotation%20matrix/</link><description>&lt;p&gt;&lt;strong&gt;李群和李代数&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;三维旋转矩阵构成特殊正交群，SO(3),变换矩阵构成了特殊欧式群SE(3).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
SO(3)=\{R \in R^{3 \times 3} \mid RR^{T} = I,det(R)=I\}
$$&lt;/p&gt;
&lt;p&gt;$$
\operatorname{SE}(3)=\left\{\mathrm{T}=\left[\begin{array}{cc}
R &amp;amp; t \\
0 &amp;amp; 1
\end{array}\right] \in \mathrm{R}^{4 \times 4} \mid R \in S O(3), t \in R^{3}\right\}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从上面看群是一种集合加上一种运算的代数结构。把集合记作A，运算记作$\bullet $，群记为G=(A,$\bullet $),群应满足以下四个特性（封结幺逆）：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;封闭性：$\forall a_{1}, a_{2} \in A, \quad a_{2} \bullet a_{3} \in A$&lt;/li&gt;
&lt;li&gt;结合律：$\forall a_{1}, a_{2}, a_{3} \in A, \quad\left(a_{1} \bullet a_{2}\right) \bullet a_{3}=a_{1} \bullet\left(a_{2} \bullet a_{3}\right)$&lt;/li&gt;
&lt;li&gt;幺元：$\exists a_{0} \in A, s . t \forall a \in A, a_{0} \bullet a=a \bullet a_{0}=a$&lt;/li&gt;
&lt;li&gt;逆：∀a∈A,∃$a^{−1}$∈A, s.t $a \bullet  a^{−1}$ = a&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;李群是指具有连续光滑性质的群,像一般的整数离散群不具有连续性，SO(3), SE(3)在实数空间上是连续的，表示一个位置变换到另一个位置，路径是连续的。但是群的概念只定义了乘法，没有加法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;李代数的引出：&lt;/p&gt;&lt;p&gt;李代数由一个集合V、一个数域F和一个二元运算[ ，]（李括号）组成。称（V,F，[ , ]）为一个李代数，记为g.&lt;/p&gt;&lt;p&gt;在实际应用中我们估计相机的位置和姿态时，由于干扰，不可能没有误差，那么产生误差需要矫正，我们会用补偿量ΔR,ΔT 去补偿误差。然而群的定义对加法没有封闭性，比如两个旋转或变换矩阵相加后不再表示一个旋转或变换矩阵，失去了原有的意义，于是李代数的提出为此问题提供了解决思路，把SE(3)空间的T映射为李代数se(3),它由向量组成，我们在中学数学就知道，向量相加还表示为一个向量（例如平行四边形原则），李代数对加法具有封闭性（加完之后还是向量）。这样可以通过李代数求导间接对变换矩阵T进行求导。在优化相机位姿时，每次迭代更新一个位姿的增量δ，使目标函数最小，那么这个δ就是通过对T微分得到的。它们对于某时刻的R(t)(李群空间)，存在一个三维向量$\phi = (\phi_1, \phi_2, \phi_3 )$的李代数空间来描述R在t时刻的导数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\dot{R}(t)=\phi(t)^{\wedge} R(t)=\left[\begin{array}{ccc} 0 &amp;amp; -\phi_{3} &amp;amp; \phi_{2} \\ \phi_{3} &amp;amp; 0 &amp;amp; -\phi_{1} \\ -\phi_{2} &amp;amp; \phi_{1} &amp;amp; 0 \end{array}\right] R(t)
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指数映射：向量$\phi = (\phi_1, \phi_2, \phi_3 )$反映了R的导数性质，它们之间的微分关系可以描述为：李代数so(3)对应李群SO(3) 在原点附近的正切空间。换句话说，李代数so(3)是三维向量$\phi = (\phi_1, \phi_2, \phi_3 )$的集合，每个$\phi (i)$的反对称矩阵都$\phi (i)$^可以表示SO(3)上旋转矩阵$R(i)$的导数,R和$\phi$又呈现一个指数映射关系：$R(t)=exp(\phi_0 ^{\wedge}t)$&lt;/p&gt;&lt;p&gt;$\exp \left(\phi^{\wedge}\right)=\exp \left(\theta \mathrm{a}^{\wedge}\right)=\sum_{n=0}^{\infty} \frac{1}{n !}\left(\theta \mathrm{a}^{\wedge}\right)^{n}$经过泰勒展开后变为$\exp \left(\theta \mathrm{a}^{\wedge}\right)= cos\left( \theta I\right) + \left( 1- cos\theta \right)aa^{T} + sin \theta \mathrm{a}^{\wedge}$又回到了罗德里格斯。对于三维旋转和变换的关系图如下;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure style="flex: 72.46376811594203" &gt;&lt;img width="500" height="345" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/7121e5cce17df61b42643df0bc961835.png" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;李代数求导与扰动模型：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以SO(3)为例，当李代数的so(3)做加法时，在李群SO(3)是否对应为两个矩阵的乘积，$exp(ϕ^{\wedge}&lt;em&gt;1)exp(ϕ^{\wedge}_2)=exp((ϕ1+ϕ2)&lt;/em&gt;{\wedge})？ln(exp(A)exp(B))=A+B？$答案是对矩阵运算都不成立，BCH公式给出了近似解：
$$
\begin{aligned}
&amp;amp; \ln \left(\exp \left(A \phi_{1}^{\wedge}\right) \exp \left(\phi_{2}^{\wedge}\right)\right)^{\vee} \
\approx &amp;amp;\left{\begin{array}{l}
J_{l}\left(\phi_{2}\right)^{-1} \phi_{1}+\phi_{2}, \phi_{1} \min \
J_{r}\left(\phi_{1}\right)^{-1} \phi_{2}+\phi_{1}, \phi_{2} \min
\end{array}\right.
\end{aligned}
$$&lt;/p&gt;&lt;p&gt;以下标为l的左乘模型来说，意思是，我们对一个旋转矩阵R2 (李代数$\phi_2$)左乘一个微小旋转矩阵R1 (李代数$\phi_1$ )，看成是李代数 $\phi_2$加上一项&lt;/p&gt;&lt;p&gt;$$
J_{l}\left(\phi_{2}\right)^{-1} \phi_{1}
$$&lt;/p&gt;
&lt;p&gt;右乘模型同理。式中有一个近似的雅可比$J_l$,再通俗的形象一下就是，假定对一个旋转R(李代数$\phi $)产生的漂移进行矫正，左乘一个ΔR (李代数Δϕ)，在李群上的结果为ΔR$\bullet$R&lt;/p&gt;&lt;p&gt;用BCH近似为&lt;/p&gt;&lt;p&gt;$$
J_{l}\left(\phi\right)^{-1}  \Delta\phi + \phi
$$&lt;/p&gt;
&lt;p&gt;合起来就是$exp(\Delta \phi^{\wedge})exp(\phi^{\wedge})= exp({(\phi +J_{l}\left(\phi\right)^{-1}  \Delta\phi )}^{\wedge})$，&lt;strong&gt;然而上面刚刚说到在李代数上加法是封闭的，可以进行加法运算&lt;/strong&gt;，一个$\phi + \Delta \phi$&lt;/p&gt;&lt;p&gt;&lt;em&gt;可以近似为李群上带左右雅可比的乘法:&lt;/em&gt;$exp((\phi +\Delta \phi)^{\wedge})=exp((J_{l}\Delta \phi)^{\wedge})exp(\phi^{\wedge})=exp(\phi^{\wedge})exp({(J_{r}  \Delta\phi )}^{\wedge})$&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;求导运算1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空间中有一向量p,然后我们对其进行了R的旋转变换变为Rp,求旋转之后Rp对旋转R的导数，$\frac{\partial(R p)}{\partial R}$，但是没有加法，无法按照导数定义计算，因此转为李代数计算。&lt;/p&gt;&lt;p&gt;$$
\frac{\partial(R p)}{\partial R}=\frac{\partial\left(\exp \left(\phi^{\wedge}\right) p\right)}{\partial \phi}=-(R p)^{\wedge} J_{l}
$$&lt;/p&gt;
&lt;p&gt;结果中有一个雅可比，在应用中不太好处理，又出现了扰动模型来替代，思路是对R进行一次扰动ΔR(左乘形式），看结果相对扰动的变化率。 ΔR对应的李代数为$\varphi$，$\frac{\partial(R p)}{\partial \varphi}=-(R p)^{\wedge}$,这样就没有了雅可比，对实际应用更加合理。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;实现才是硬道理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="#harmful-link"&gt;&lt;figure style="flex: 50.0" &gt;&lt;img width="20" height="20" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/0b926442b9a767983066a04a1b07b067.gif" /&gt;&lt;figcaption&gt;复制代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1 #include&amp;lt;iostream&amp;gt;
 2 #include&amp;lt;cmath&amp;gt;
 3 #include&amp;lt;Eigen/Core&amp;gt;
 4 #include&amp;lt;Eigen/Geometry&amp;gt;
 5 #include&amp;quot;sophus/se3.h&amp;quot;
 6 #include&amp;quot;sophus/so3.h&amp;quot;
 7 
 8 using namespace std;
 9 using namespace Eigen;
10 
11 int main(int argc,char **argv)
12 {
13     // 沿Z轴转90度的旋转矩阵用旋转向量表示
14     Eigen::Matrix3d R = Eigen::AngleAxisd(M_PI/2, Eigen::Vector3d(0,0,1)).toRotationMatrix();
15     
16     Sophus::SO3 SO3_R(R);               // Sophus::SO(3)可以直接从旋转矩阵构造
17     Sophus::SO3 SO3_v( 0, 0, M_PI/2 );  // 亦可从旋转向量构造
18     Eigen::Quaterniond q(R);            // 或者四元数
19     Sophus::SO3 SO3_q( q );
20     // 上述表达方式都是等价的
21    
22     cout&amp;lt;&amp;lt;&amp;quot;SO(3)由矩阵构造:\n &amp;quot;&amp;lt;&amp;lt;SO3_R.matrix()&amp;lt;&amp;lt;endl;
23     cout&amp;lt;&amp;lt;&amp;quot;SO(3)由向量构造: \n&amp;quot;&amp;lt;&amp;lt;SO3_v.matrix()&amp;lt;&amp;lt;endl;
24     cout&amp;lt;&amp;lt;&amp;quot;SO(3)由四元数构造:\n&amp;quot;&amp;lt;&amp;lt;SO3_q.matrix()&amp;lt;&amp;lt;endl;
25     
26     // 使用对数映射获得它的李代数
27     Eigen::Vector3d so3 = SO3_R.log();
28     cout&amp;lt;&amp;lt;&amp;quot;SO(3)的李代数so(3) =SO3_R.log()为： &amp;quot;&amp;lt;&amp;lt;so3.transpose()&amp;lt;&amp;lt;endl;
29     // hat 为向量到反对称矩阵
30     cout&amp;lt;&amp;lt;&amp;quot;so(3)李代数向量对应的反对称矩阵： \n&amp;quot;&amp;lt;&amp;lt;Sophus::SO3::hat(so3)&amp;lt;&amp;lt;endl;
31     // 相对的，vee为反对称矩阵到向量
32     cout&amp;lt;&amp;lt;&amp;quot;so(3)反对称矩阵对应的李代数向量： \n &amp;quot;&amp;lt;&amp;lt;Sophus::SO3::vee( Sophus::SO3::hat(so3) ).transpose()&amp;lt;&amp;lt;endl;
33     // transpose纯粹是为了输出美观一些
34     
35     // 增量扰动模型的更新
36     Eigen::Vector3d update_so3(1e-4, 0, 0); //假设更新量为这么多
37     Sophus::SO3 SO3_updated = Sophus::SO3::exp(update_so3)*SO3_R;
38     cout&amp;lt;&amp;lt;&amp;quot;更新后的SO(3) =δ×R为 \n&amp;quot;&amp;lt;&amp;lt;SO3_updated.matrix()&amp;lt;&amp;lt;endl;
39     
40     cout&amp;lt;&amp;lt;&amp;quot;***********SE(3)的操作*************&amp;quot;&amp;lt;&amp;lt;endl;
41     // 对SE(3)操作大同小异
42     Eigen::Vector3d t(1,0,0);           // 沿X轴平移1
43     Sophus::SE3 SE3_Rt(R, t);           // 从R,t构造SE(3)
44     Sophus::SE3 SE3_qt(q,t);            // 从q,t构造SE(3)
45     cout&amp;lt;&amp;lt;&amp;quot;SE3由矩阵旋转+平移构造（ R,t)= &amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;SE3_Rt.matrix()&amp;lt;&amp;lt;endl;
46     cout&amp;lt;&amp;lt;&amp;quot;SE3由四元数q,t= &amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;SE3_qt.matrix()&amp;lt;&amp;lt;endl;
47     // 李代数se(3) 是一个六维向量，方便起见先typedef一下
48     typedef Eigen::Matrix&amp;lt;double,6,1&amp;gt; Vector6d;
49     Vector6d se3 = SE3_Rt.log();
50     cout&amp;lt;&amp;lt;&amp;quot;SE(3)对应的李代数se(3) =\n &amp;quot;&amp;lt;&amp;lt;se3.transpose()&amp;lt;&amp;lt;endl;
51     // 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后.
52     // 同样的，有hat和vee两个算符
53     cout&amp;lt;&amp;lt;&amp;quot;se(3)对应的反对称矩阵 = &amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;Sophus::SE3::hat(se3)&amp;lt;&amp;lt;endl;
54     cout&amp;lt;&amp;lt;&amp;quot;反对称矩阵对应的李代数向量 = &amp;quot;&amp;lt;&amp;lt;Sophus::SE3::vee( Sophus::SE3::hat(se3) ).transpose()&amp;lt;&amp;lt;endl;
55     
56     // se(3)的扰动
57     Vector6d update_se3; //更新量
58     update_se3.setZero();//六维更新量
59     update_se3(0,0) = 1e-4d;//改变其中一个量来产生观测
60     Sophus::SE3 SE3_updated = Sophus::SE3::exp(update_se3)*SE3_Rt;
61     cout&amp;lt;&amp;lt;&amp;quot;更新后的SE(3) = &amp;quot;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;SE3_updated.matrix()&amp;lt;&amp;lt;endl;
62     
63 return 0;
64 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="#harmful-link"&gt;&lt;figure style="flex: 50.0" &gt;&lt;img width="20" height="20" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/0b926442b9a767983066a04a1b07b067.gif" /&gt;&lt;figcaption&gt;复制代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;/a&gt;&lt;/p&gt;&lt;figure style="flex: 90.92071611253196" &gt;&lt;img width="711" height="391" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/a30675a91c5f31cf748c49e3e484f009.png" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure style="flex: 97.57281553398059" &gt;&lt;img width="804" height="412" src="https://cdn.jsdelivr.net/gh/LSQsjtu/Blog@gh-pages/archives/assets/226f0fda8fb394fa5a16a443cacc2a57.png" /&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/rotation%20matrix/</guid><pubDate>Sat, 29 Jan 2022 00:00:00 +0806</pubDate></item><item><title>钢琴家</title><link>/Blog/archives/The%20pianist/</link><description>&lt;p&gt;&lt;strong&gt;The pianist&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更像是以第一视角去体验二战时期，华沙地区犹太民族的辛酸和苦痛，不同名族，种族的对立与厌恶，不同性格阶级人民的对立。&lt;/p&gt;&lt;p&gt;作为犹太人，从一开始的经济限制到固定居所，最后送到集中营自生自灭。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;全剧中有直接了当是血腥画面，第三视角的悲伤（更多），满街的尸体，到处的废墟，没有一丝生机，全是战争的疮痍&lt;/li&gt;
&lt;li&gt;小孩，妇女，老人每处都有迫害的细节，难以直视&lt;/li&gt;
&lt;li&gt;常常感受到无言中透露的对战争的控诉&lt;/li&gt;
&lt;/ul&gt;
</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/The%20pianist/</guid><pubDate>Sat, 12 Feb 2022 00:00:00 +0806</pubDate></item><item><title>日本五十音图学习</title><link>/Blog/archives/aeiou/</link><description>&lt;p&gt;&lt;strong&gt;五十音图&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;基础知识&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;文字组成&lt;ul&gt;
&lt;li&gt;汉字&lt;/li&gt;
&lt;li&gt;假名（平假名，片假名）&lt;/li&gt;
&lt;li&gt;罗马数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;汉字某些是一样的，但部分字不一样，且有部分相同字不一样意思&lt;/li&gt;
&lt;li&gt;假名&lt;ul&gt;
&lt;li&gt;平假名：简单易懂的假借的汉字，常用在日常表达&lt;/li&gt;
&lt;li&gt;片假名：片面假借的汉字部首，用于外来词，拟声拟态词，动植物名称；也有用来表示强调&lt;/li&gt;
&lt;li&gt;平假名和片假名一一对应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/aeiou/</guid><pubDate>Sun, 20 Feb 2022 00:00:00 +0806</pubDate></item><item><title>nerf</title><link>/Blog/archives/nerf/</link><description>&lt;p&gt;&lt;strong&gt;nerf&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;链接：&lt;a href="https://www.youtube.com/watch?v=otly9jcZ0Jg&amp;amp;t=5215s"&gt;nerf介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;volumetric rendering&lt;/p&gt;&lt;p&gt;ray_o, ray_d输入，返回rgb值，和真值算MSE loss。&lt;/p&gt;&lt;p&gt;volumetric density积分转化为分段&lt;/p&gt;&lt;p&gt;xyz低维信息，难以使用，通过input coordinate mapping 转化为Fourier feature&lt;/p&gt;&lt;p&gt;转换通过B matrix，最终性能和B matrix有较大关系&lt;/p&gt;&lt;p&gt;problem：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;li&gt;过拟合和欠拟合&lt;/li&gt;
&lt;/ul&gt;
</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/nerf/</guid><pubDate>Sat, 26 Feb 2022 00:00:00 +0806</pubDate></item><item><title>animate paper</title><link>/Blog/archives/animate%20paper/</link><description>&lt;p&gt;&lt;strong&gt;3D Menagerie: Modeling the 3D Shape and Pose of Animals&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;task:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;fitting new animals from template&lt;/li&gt;
&lt;li&gt;deformation by SMAL&lt;/li&gt;
&lt;li&gt;fit animals to image&lt;/li&gt;
&lt;li&gt;combine the 3D scans and images&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;problem:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;less data&lt;/li&gt;
&lt;li&gt;difficult tail part&lt;/li&gt;
&lt;li&gt;a variety of data species&lt;/li&gt;
&lt;/ul&gt;
</description><author>1959376918@qq.com (刘胜琪)</author><guid isPermaLink="true">/Blog/archives/animate%20paper/</guid><pubDate>Tue, 22 Mar 2022 00:00:00 +0806</pubDate></item></channel></rss>